# 算法:

#### 字符串反转:
对hello,word反转,输出结果drow,polleh
思路:设置两个指针,一个指向开头一个指向结尾.交换指向开头和结尾的指针,逐次向内移动这两个指针,退出条件begin>=end(index).
```
void char_reverse(char *cha){
  char *begin = cha;
  char *end = cha + strlen(cha) - 1;
  while (begin <= end) {
    char temp = *end;
    *(end--) = *begin;
    *(begin++) = temp;
  }
}
```
#### 链表反转:例子
`
1->2->3->4->NULL
变成4->3->2->1->NULL
思路:头插法.定义一个新的指针NewH指向为NULL,然后定义一个临时变量p指针进行原有链表的遍历动作,然后将NewH后依次指向链表中的元素并且添加到链表中知道原链表为NULL.
`
#### 如何打印链表
```
1. 构造链表结构,结构体类型以及构造函数
    1. 初始化两个链表结构体,指向NULL,head和cur
    2. for循环遍历,初始化node链表分配内存空间以及data值和next值确定
        3. 当head为NULL,以及不为NULL时cur->next为node;
        4. cur赋值为node;
2. 链表翻转使用头插法翻转
    1. 创建新链表newH指向NULL
    2. 循环原链表直到!=NULL
        1. 创建temp链表指向next
        2. 原链表的next赋值为newH
        3. newH赋值为循环中的p
        4. 移动p为temp
```

##### 如何利用c语言构造双向链表
1 <-> 2 <-> 3 <-> 4 <-> 5
```
1. 声明结构体,内部含有headNode,nextNode,data
2. 构造函数
    1. 初始化头部节点
        1. 分配内部属性赋值NULL,NULL,1,以及内存地址
        2. 创建list用来指向首节点方便后续移动
    2. 循环遍历
        1. 初始化bodyNode,分配内存地址以及设置初始值NULL,NULL,i
        2. list的next指向body,首部默认指向NULL
        3. bodyNode的headNode指向list
        4. list指向list的nextNode
```

#### 归并算法:有序数组合并以及无序数组合并(先冒泡排序):[1,4,5,7,9],[2,4,5,6,7,8]怎么合并为一个数组
思路,准备一个内容是两者总长度的数组,准备两个p,q指针分别指向两个数组的头部,依次比较谁小,小的填充到新数组前面并且移动该小值所在数组指针到下一个元素.再次比较,直到其中一个数组内无元素,填充另一数组内容到新数组后.
```
1. 准备变量p,q,i.
2. 循环遍历p < aLen && q < bLen
    当a[p] <= b[q]
    result[i]找到对应小的值填充,并且i++

3. 循环遍历若p < alen,以及q < blen时内部数组值依次加入到result[i]中,i++.准备下一个值填充
```

#### 哈希算法:在一个字符串中找到第一个只出现一次的字符
abaccdeff,输出b.

字符对应ASCII码作为数组下标对应的数字,相当于字母和ASCII建立映射关系,储存每个字母在对应下标个数.
```
1. 初始化数组长度256,循环遍历数组赋值,赋值为arr[*(cha++)]++,字符串指针向后移动(下标一一对应),以及数组向后移动256内都有下标值
2. 循环遍历原字符串,找到*cha下标内元素的值.值为次数,为1退出循环否则继续遍历.

```


#### 查找两个子视图的共同父视图算法:思路,记录viewA,B的全部父视图知道找到nil存在不同数组中,倒序遍历知道找到两个数据组最小的一个没有共同父视图
核心思想:倒序遍历两者的父类最开始都一样.
```
1. 查找父视图
    1. findSuperViews():临时变量指向当前视图的父视图,while循环临时变量,知道找到nil退出
    2. while循环()条件i小于两个数组个数最小的退出循环
        倒序取出,判断父视图是否相同.存到数组中就是共同父视图.
```


#### 求无序数组中的中位数:
1. 利用排序算法+中位数(排序,找中位数忽略)
2. 快排思想:选取关键字高低交替扫描.
low,high指值,高指针向前遍历找到第一个比关键字小的数字,交换.低指针找打第一个比关键字大的交换.

#### 二叉树遍历:
前序遍历NLR:先访问根节点,再访问左节点再访问右节点
中序遍历LNR:先访问左节点,再访问根节点,最后访问右节点
倒序遍历LRN:先访问左节点节点,再访问右节点,最后访问跟节点.

https://www.jianshu.com/p/a270d117e116
```

```

#### 怎么判断环形链表:追赶思想
设定fast和slow两指针,fast前进两步,slow前进一步,相遇就是环形结构.
且碰撞点到头节点的距离为环中节点数n

```
whild (fast && slow)
fast->next->next
slow->next

if(fast->val == slow->val )
break
```


#### 二分查找:递归思想
前提是有序数组.头尾的概念,将中间节点作为下一次查找的头结点或者尾节点知道找到值.
```

```

#### 递归算法:
1. 斐波那契数列:0,1,1,2,3,5前两个数之和是带三个数
:定义一个斐波那契数组,第一个值是0,第二个值是1,传入具体n次相加,每次数组内都是前两者相加的和.
JAVA实现:

```
    
    public static int fib1(int n) {
        if (n <= 1) return n;
        return fib1(n-1) + fib1(n-2);
    }

    public static int fib2(int n) {
        if (n <= 1) return n;
        int first = 0;
        int second = 1;
        for (int i = 0; i < n-1; i++) {
            int sum = first + second;
            first = second;
            second = sum;           
        }
        return second;
    }


    public static int fib3(int n) {
        if (n <= 1) return n;
        int first = 0;
        int second = 1;
        while ((n--) - 1 > 0) {
            second = first + second;
            first = second - first;
        }
        return second;
    }

```

2. 递归怎么改循环
```
所有递归都可以改为循环,因为都有一段代码反复调用
斐波那契数列循环怎么做?
循环条件<n(相加次数)
sum = a + b
a = b
b = sum

return sum.
```




#### 排序算法:(最好能手敲)
1. 冒泡排序
核心思想:相互比较,两两交换,大的后移,小的前移
```
j = j - i - i;交换

空间复杂度:O(1)

时间复杂度:O(n2)
最好情况:数组已经排列好,O(n)
最坏情况:数组倒序,O(n2)
一般情况:O(n2)
稳定的排序算法:数组里两个相等的数,经过排序位置保持不变.
```


2. 插入排序
核心思想:一般认为第一个元素是已经排好序的,其他元素不断将将未排序的数据插入已经排好序的部分.
```
情景:将数组分为两个部分,前部分为一个元素,逐次从后面部分拿出元素,和前部分已经排好序的进行比较,小的插入前面,大的插入到后面.重复此操作

1. 声明current用来标识当前插入数据
    current = arr[i];
2. 两层循环
    第二层循环条件,(j=i-1;j>=0 && arr[j] > current;j--) {
        arr[j+1] = arr[j];
    }
    arr[j+1] = current;


空间复杂度:O(1)
时间复杂度:O(n2)
最好情况:数组已经排列好,O(n)
最坏情况:数组倒序,O(n2)
一般情况:O(n2)
稳定的排序算法:数组里两个相等的数,经过排序位置保持不变.


```
3. 快速排序:分治思想
将原始数组筛选成一个较大和一个较少数组.,然后递归排序两个子数组.
当所有子数组中元素都为1时原始数组其实已经排好序了.
```
时间复杂度:O(nlog2n)
空间复杂度:O(nlog2n)
```
4. 归并排序:分治思想,将复杂问题拆分成若干个简单问题.
一开始将数组从中间分为两个子数组,一直递归的将子数组划分为更小的数组,知道子数组只有一个元素(可以理解为二叉树查分).
依次按照递归的返回顺序,不断合并排序好的子数组,知道最后整个数组合并好.

时间复杂度:O(n)
控件复杂度O(nlog2n);
```

```
5. 拓扑排序(关系排序)
```
直接画出图论,找到每个开始节点,然后擦除连接此节点的线,再找下个开始节点.
```
6. 堆排序(高级)
二叉树,相当于每次遍历当前二叉树找到最大的值,移动到堆顶.当所有二叉树被移动完时,最大根节点就是最大的数,二叉树内移除最大的数,再次循环新的二叉树.完成排序.
```
```
7. 桶排序(高级)


什么是哈希冲突;
当前key通过哈希算法访问的值存在多个时,就会产生哈希冲突,没法避免.
1. 拉链法:
    将冲突的hash值,存放到链表中.后续查找也是先找到该链表,再找到链表内确定的hash值.


完全二叉树?
红黑树?


#### 八匹马面试题:
```
64匹马8跑道找到最快的四匹?
第一步,8场一起跑,淘汰每场后四匹马.(肯定不是) 剩32匹
第二步:1场.取第一轮第一名再比一场.淘汰后四名中所有马.16
第三步:1场:此时已经知道第一名了,
然后拿出第一名组里面的三匹,第二名组里面的前三,第三名组里面的前二.第四名组的前一
九匹马已知冠军马.
此时总共还有九匹马.找到九匹马里面的前八名
取2,3,4和未比的跑一场,取前三.加冠军马.
```
#### 25个小朋友跑步，没有秒表，一次跑步能跑5个人，请问最少跑几次，一定能找到跑的最快的那5个小朋友
```
第一步:1次,5*5
第二步冠军:1次,第一名
第三步:1次,第二名,
第四步:1次,第三名,
第五步:1次,第四名,
第六步:1次,第五名.
```

#### 9砝码一个轻.最少称几次找到此法码.
```
2次,
第一次:3个一起.同重在另外.非同重在轻的,
第二次:1个一起,同重轻的另外,非同重,找轻的.
```


#### 链表和数组的区别:
```
数组连续空间,插入和删除效率低,查询速度快,可能浪费内存.
链表:插入删除速度快,查询速度慢(不能随机查找需要从链表头结点逐级遍历),内存可以充分利用.
```

